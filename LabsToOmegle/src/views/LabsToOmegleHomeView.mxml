<?xml version="1.0" encoding="utf-8"?>
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009" 
		xmlns:s="library://ns.adobe.com/flex/spark" 
		title="HomeView"
		xmlns:mx="library://ns.adobe.com/flex/mx" 
		actionBarVisible="false"
		creationComplete="init()" 
		xmlns:flextras="http://www.flextras.com/mxml"
		viewActivate="backListener_Init()"
		viewDeactivate="backListener_Close()">
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			
			import com.adobe.serialization.json.JSON;
			
			import flash.events.AccelerometerEvent;
			import flash.events.GeolocationEvent;
			import flash.sensors.Accelerometer;
			import flash.sensors.Geolocation;
			
			import mx.collections.ArrayList;
			import mx.formatters.DateFormatter;
			import mx.graphics.codec.JPEGEncoder;
			import mx.graphics.codec.PNGEncoder;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.rpc.http.HTTPService;
			import mx.utils.Base64Encoder;
			import mx.utils.ObjectUtil;
			import mx.utils.UIDUtil;
			
			import org.osmf.net.NetClient;
			import flash.net.URLRequestDefaults;
			
			private var baseUrl:String = "http://10.201.12.165/"; 
			private var rtmpBaseUrl:String = "rtmp://10.201.12.165/";
			
			private var controlledSocket:PacketSocket;
			
			private var strangerPeerID:String;
			
			private var netConnection:NetConnection;
			private var localStream:NetStream;
			private var remoteStream:NetStream;
			private var remoteVideo:Video;
			private var localVideo:Video;
			
			private var mic:Microphone;
			private var camera:Camera;
			[Bindable] private var micNames:ArrayList = new ArrayList();
			private var micIndex:int = 0;
			[Bindable] private var cameraNames:ArrayList = new ArrayList();
			private var cameraIndex:int = 0;
			private var cameraInfo:String;
			
			private var localSO:SharedObject;
			private var uuid:String;
			private var sessionid:String;
			private var randID:String;
			
			private const NotStart:String = "NotStart";
			private const NetConnectFail:String = "NetConnectFail";
			private const Chatting:String = "Chatting";
			private const Binding:String = "Binding";  // Binding state is not used any more
			private const Waiting:String = "Waiting";
			private const Connecting:String = "Connecting";
			
			private var disconnectTimer:Timer;
			
			private var acc:Accelerometer;
			private var accInterval:int = 0;			
			private var accObjs:Object = new Object();	
			private var accPostDuration:int  = 6300;
			private var accPostTimer:Timer;
			
			private var gps:Geolocation;
			private var gpsInterval:int = 1000;
			private var gpsObjs:Object = new Object();
			private var gpsPostDuration:int = 5300;
			private var gpsPostTimer:Timer;
			
			//private var gyro:Gyroscope;
			private var gyroInterval:int = 1000;
			private var gyroObjs:Object = new Object();
			private var gyroPostDuration:int = 7300;
			private var gyroPostTimer:Timer;
			
			private var imgByteArray:ByteArray;
			
			
			private var webView:StageWebView;
			
			private var audio_nc:NetConnection;
			private var audio_ns:NetStream;
			private var audioTimer:Timer;
			
			private var imgDuration:int = 30000;
			private var imgTimer:Timer;
			
			private var audioCollectDuration:int = 10000;
			private var audioIdleDuration:int = 30000;
			
			private var collectflag:int;
			
			private var gyroflag:int;
			
			public function init():void{
				trace("Application Init");
				
				URLRequestDefaults.idleTimeout = 1200000;
				//mic = Microphone.getMicrophone();
				trace("init");
				NativeApplication.nativeApplication.addEventListener(Event.DEACTIVATE, onDeactivateApp);
				currentState = NotStart;
				localSO = SharedObject.getLocal("Omegle");
				uuid = getUserID();
				trace("uuid:\t"+uuid);
				
				// load label for spinner 
				var mics:Array = Microphone.names;
				mics[0] = new Array("Mic")[0];
				if (mics)
				{
					micNames.source = mics;
					micSelection.dataProvider = micNames;
				}
				else
				{
					trace("No microphone available.\n");
				}			
				var cameraLen:int = Camera.names.length;
				var cameras:Array;
				if(cameraLen == 1){
					cameras = new Array("Back Cam");
					cameraNames.source = cameras;
				}
				else if(cameraLen == 2){
					cameras = new Array("Back Cam","Front Cam");
					cameraNames.source = cameras;
				}
				cameraSelection.dataProvider = cameraNames;
				
				//select device
				micIndex = 0;
				if (localSO.data.hasOwnProperty("micIndex"))
				{
					micIndex = localSO.data.micIndex;
				}
				
				micSelection.selectedIndex = micIndex;		
				cameraIndex=0;
				if (localSO.data.hasOwnProperty("cameraIndex"))
				{
					cameraIndex = localSO.data.cameraIndex;
				}				
				cameraSelection.selectedIndex = cameraIndex;
				udpateCameraInfo(cameraIndex);
				
				//load device							
				mic = Microphone.getMicrophone();
				if (mic)
				{						
					micChanged();
				}
				
				camera = Camera.getCamera(cameraIndex.toString());
				if (camera)
				{
					cameraChanged();
				}
				//textInput.enabled = false;
				sendbtn.enabled = false;
				textOutput.text = "";
				textOutput.validateNow();
				textInput.text = "";
				textInput.validateNow();
				
				collectflag = 1;
				gyroflag = 0;
				loadAppStatus();
				
				loadParameter();
			}
			
			private function loadAppStatus():void{
				var parHttpServ:HTTPService = new HTTPService();
				parHttpServ.url = baseUrl+"cgi-bin/loadAppStatus.cgi";
				parHttpServ.cancel();
				parHttpServ.send();
				parHttpServ.addEventListener("result", loadAppResult);
				parHttpServ.addEventListener("fault", loadAppFault);
			}
			
			private function loadAppResult(e:ResultEvent):void
			{	
				var response:String = e.result.toString();
				var parArray:Array = response.split("\n");
				var AppStatus:String = parArray[0].toString().split(":")[1];
				trace("AppStatus is : "+AppStatus);
				if(AppStatus.search("false")!=-1){
					trace("In if of loadAppResult");
					NativeApplication.nativeApplication.exit();
				}
				else if(AppStatus.search("stop")!=-1){
					trace("In else if of loadAppResult");
					collectflag = 0;
					trace("STOP DATA COLLECTION!!!!");
				}
			}
			
			private function loadAppFault(e:FaultEvent):void
			{	
				trace("LoadAppResultError");		
			}
			
			private function loadParameter():void{
				var parHttpServ:HTTPService = new HTTPService();
				parHttpServ.url = baseUrl+"cgi-bin/loadParameter.cgi";
				parHttpServ.cancel();
				parHttpServ.send();
				parHttpServ.addEventListener("result", loadParaResult);
				parHttpServ.addEventListener("fault", loadParaFault);
			}
			
			private function loadParaResult(e:ResultEvent):void
			{
				//trace(e.result.toString());
				//trace("LoadParaReuslt: "+e.message.body.toString());
				var response:String = e.result.toString();
				var parArray:Array = response.split("\n");
				//trace(parArray.length)
				for(var i:int = 0; i<parArray.length; i++){
					var key:String = parArray[i].toString().split(":")[0];
					if(key == "acc"){
						accInterval = parArray[i].toString().split(":")[1].toString().split(";")[0];
						accPostDuration = parArray[i].toString().split(":")[1].toString().split(";")[1];
						trace("acc duration :" + accPostDuration);
						trace("acc interval :" +accInterval);
						//trace("acc post timer :" +accPostTimer.delay);
						accPostTimer = new Timer(accPostDuration);
						trace("acc post timer :" +accPostTimer.delay);
					}
					else if(key == "gps"){
						gpsInterval = parArray[i].toString().split(":")[1].toString().split(";")[0];
						gpsPostDuration = parArray[i].toString().split(":")[1].toString().split(";")[1];
						//gpsPostTimer = new Timer(gpsPostDuration);
					}
					else if(key == "gyro"){
						gyroInterval = parArray[i].toString().split(":")[1].toString().split(";")[0];
						gyroPostDuration = parArray[i].toString().split(":")[1].toString().split(";")[1];
						trace(gyroPostDuration)
						//gyroPostTimer = new Timer(gyroPostDuration);
					}
					else if(key == "img"){
						imgDuration = parArray[i].toString().split(":")[1];
						//trace(imgDuration)
						//imgTimer = new Timer(imgDuration);
						//trace(imgTimer.delay);
					}
					else if(key == "audio"){
						audioCollectDuration = parArray[i].toString().split(":")[1].toString().split(";")[0];
						audioIdleDuration = parArray[i].toString().split(":")[1].toString().split(";")[1];
						//trace(audioCollectDuration);
						//trace(audioIdleDuration);
					}
					else{
						
					}
				}				
			}
			
			private function loadParaFault(e:FaultEvent):void
			{	
				trace("LoadParaResultError");				
			}
			
			private function getUserID():String{
				var usrid:String;
				if (localSO.data.hasOwnProperty("userID"))
				{
					usrid = localSO.data.userID;
					
				}
				else{
					usrid = "mobile-"+UIDUtil.createUID();
					trace("No UserID exists! Generated!!");
					localSO.data.userID = usrid;
					try
					{
						localSO.flush();
					}
					catch (e:Error)
					{
						trace("Cannot write userid info to shared object\n");
					}
				}
				return usrid;
			}
			
			private function udpateCameraInfo(camIdx:int):void{
				if(camIdx.toString()=="0")
					cameraInfo = "back";
				else
					cameraInfo = "front";
				trace("Update Camera Info:\t"+cameraInfo);
			}
			
			private function micChanged(event:Event = null):void
			{
				micIndex = micSelection.selectedIndex;			
				mic = Microphone.getMicrophone(micIndex);
				
				// set the new microphne values based on UI
				mic.gain = 70;
				mic.noiseSuppressionLevel = -500;
				mic.setUseEchoSuppression(true);
				mic.rate = 44;
				//mic.codec = SoundCodec.SPEEX;
				//mic.framesPerPacket = 1;
				//mic.encodeQuality = 6;
				mic.setSilenceLevel(0);
				//mic.activityLevel = 30;	
				mic.addEventListener(StatusEvent.STATUS, onMicDeviceStatus);
				mic.addEventListener(ActivityEvent.ACTIVITY, onMicDeviceActivity);
				
				if (currentState == Chatting)
				{	
					this.localStream.attachAudio(mic);
				}
				
				localSO.data.micIndex = micIndex;
				try
				{
					localSO.flush();
				}
				catch (e:Error)
				{
					trace("Cannot write mic info to shared object\n");
				}
				
			}
			
			private function onMicDeviceStatus(e:StatusEvent):void
			{
				trace("Mic status: " + e.code + "\n");
			}
			
			private function onMicDeviceActivity(e:ActivityEvent):void
			{
				trace("Mic activity: " + e.activating + "\n");
			}
			
			private function cameraChanged(event:Event = null):void
			{				
				cameraIndex = cameraSelection.selectedIndex;
				udpateCameraInfo(cameraIndex);
				camera = Camera.getCamera(cameraIndex.toString());		
				if (camera)
				{
					//var video 	: Video 	= new Video(400, 320);
					var video 	: Video 	= new Video(160,120);
					camera.setMode(160, 120, 24);
					camera.setQuality(0, 75);
					video.attachCamera(camera);
					//video.rotation = 90;
					localVideoDisplay.addChild(video);
					camera.addEventListener(StatusEvent.STATUS, onCameraDeviceStatus);
					camera.addEventListener(ActivityEvent.ACTIVITY, onCameraDeviceActivity);
				}		
				if (currentState == Chatting)
				{	
					this.localStream.attachCamera(camera);
				}					
				localSO.data.cameraIndex = cameraIndex;
				try
				{
					localSO.flush();
				}
				catch (e:Error)
				{
					trace("Cannot write camera info to shared object\n");
				}				
				
			}
			
			private function onCameraDeviceStatus(e:StatusEvent):void
			{
				//trace("Camera status: " + e.code + "\n");
			}
			
			private function onCameraDeviceActivity(e:ActivityEvent):void
			{
				//trace("Camera activity: " + e.activating + "\n");
			}
			
			private function onStart():void {
				
			}
			
			private function onStop():void {
				
			}
			
			private function onCancel():void {
				
			}
			
			private function onType():void {
				
			}
			
			private function stopType():void {
				
			}
			
			private function onSend():void {
				
			}
			
			private function backListener_Init():void
			{
				NativeApplication.nativeApplication.addEventListener(KeyboardEvent.KEY_DOWN, keyDown);
				NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.KEEP_AWAKE;
				trace("Listener Init");
			}
			
			private function keyDown(e:KeyboardEvent):void
			{
				
			}
			private function backListener_Close():void
			{
				
				trace("Listener close!!!!!");
				NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.NORMAL;
			}
			
			protected function onDeactivateApp(event:Event):void
			{
				trace("App Deactivate")
				collectflag = 1;
				
				NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.NORMAL;
			}
			
		]]>
	</fx:Script>
	
	<s:states>
		<s:State name="NotStart"/>
		<s:State name="Connecting"/>
		<s:State name="NetConnectFail"/>
		<s:State name="Chatting"/>
		<s:State name="Binding"/> 
		<s:State name="Waiting"/>
	</s:states>
	
	<s:Scroller width="100%" height="100%">
		<s:VGroup>			
			<s:HGroup>
				<s:VGroup>
					<s:HGroup>
						<s:TextInput focusIn="onType()" focusOut="stopType()" id="textInput" width="110" height="40" 
									 softKeyboardType="default" enter="onSend()" />
						<s:Button id="sendbtn" label="Send" fontSize="12" width="50"  height="40" click="onSend()"/>
					</s:HGroup>
					<s:TextArea id="textOutput" width="160" height="120" editable="false" verticalScrollPolicy="auto" color="black"/>
					<mx:UIComponent id="localVideoDisplay" width="160" height="120"/>
					
				</s:VGroup>
				<s:VGroup>
					<s:HGroup  verticalAlign="middle">
						<flextras:DropDownList id="micSelection" change="micChanged(event)"  fontSize="12" color="black" width="90" height="40" />
						<flextras:DropDownList id="cameraSelection" change="cameraChanged(event)"  fontSize="12" color="black" width="90" height="40"/>
						<s:Button id="startbtn" label="Start" click="onStart()" fontSize="12" height="40" includeIn="NotStart,NetConnectFail"/>
						<s:Button id="stopbtn" label="Disconnect" click="onStop()" fontSize="12" height="40" includeIn="Chatting,Waiting"/>
						<s:Label text="Network Connection Fail" fontSize="12" verticalAlign="middle" height="40" includeIn="NetConnectFail" color="0xffffff"/>
						<s:Label text="Please Wait! No User Can Pair" fontSize="10" height="40" verticalAlign="middle" includeIn="Waiting" color="0xffffff"/>
						<s:Label text="Binding Stream..." fontSize="15" height="40" verticalAlign="middle" includeIn="Binding" color="0xffffff"/>
						<s:Label text="Connecting..." fontSize="15" height="40" verticalAlign="middle" includeIn="Connecting" color="0xffffff"/>
						<s:Button id="cancelbtn" label="Cancel" click="onCancel()" fontSize="12"  height="40" includeIn="Connecting"/>
					</s:HGroup>	
					<mx:UIComponent id="remoteVideoDisplay" width="320" height="240"/>
					
				</s:VGroup>	
			</s:HGroup>	
			<s:Label text="NOTE: Use earphone to have better performance" fontSize="15" height="40" verticalAlign="middle" color="0xdf0101"/>
		</s:VGroup>
	</s:Scroller>
</s:View>
